#pragma kernel Copy
#pragma kernel Erase
#pragma kernel CopyHighlight
#pragma kernel FinalCopy
#pragma kernel TimeRemap
#pragma kernel UpdateIDTex

// struct TexToBuffer
// {
//     uint pos;
//     float color;
// };

Texture2D<float> _OrgTexColor;
RWTexture2D<float> _FinalTexColor;
RWTexture2D<float> _FinalTexID;
RWTexture2D<int> _TempTexID;

StructuredBuffer<float4> _TimeRemap;
StructuredBuffer<int4> _IndexRemap;
StructuredBuffer<int4> _EraseRemap;
StructuredBuffer<int> _HighlightIndex;

//AppendStructuredBuffer<TexToBuffer> _TexToBuffer;
RWStructuredBuffer<int> _Counter;
RWStructuredBuffer<int> _BrushStrokeBounds;

int _StartPosX;
int _StartPosY;

float _StrokeID;
float _OffsetUV;

uint CompactPos(uint2 xy)
{
    uint x = xy.x;
    uint y = xy.y;
    x = x << 16;
    x = x >> 16;
    y = y << 16;
    return x | y;
}

float Remap (float value, float from1, float to1, float from2, float to2) 
{
    return (value - from1) / (to1 - from1) * (to2 - from2) + from2;
}

[numthreads(32,32,1)]
void Copy (uint2 id : SV_DispatchThreadID)
{
    if(_OrgTexColor[id] > 0 && _TempTexID[id] == 0)
    {
        _TempTexID[id] = float4(1, 0, 0, 0);
        _FinalTexColor[id] = _OrgTexColor[id];
    }
}

[numthreads(32,32,1)]
void FinalCopy (uint2 id : SV_DispatchThreadID)
{
    if(_OrgTexColor[id] > 0)
    {
        // TexToBuffer texToBuffer;
        // texToBuffer.pos = CompactPos(id);
        // texToBuffer.color = _OrgTexColor[id];
        // _TexToBuffer.Append(texToBuffer);
        // InterlockedAdd(_Counter[0], 1);
        
        InterlockedMin(_BrushStrokeBounds[0], id.x);
        InterlockedMin(_BrushStrokeBounds[1], id.y);
        InterlockedMax(_BrushStrokeBounds[2], id.x);
        InterlockedMax(_BrushStrokeBounds[3], id.y);
        
        if(_FinalTexID[id] < 0 || _StrokeID < _FinalTexID[id])
        {
            _FinalTexColor[id] = _OrgTexColor[id];
            _FinalTexID[id] = float4(_StrokeID, 0, 0, 0);
        }
    }
}


[numthreads(32,32,1)]
void Erase (uint2 id : SV_DispatchThreadID)
{
    id += uint2((uint)_StartPosX, (uint)_StartPosY);
    int brushID = _FinalTexID[id];
    if(brushID < 0)
    {
        return;
    }
    
    int shouldErase = _EraseRemap[brushID].x;
    if(shouldErase > 0)
    {
        _FinalTexID[id] = -1;
        _FinalTexColor[id] = 0;
    }
}

[numthreads(32,32,1)]
void CopyHighlight (uint2 id : SV_DispatchThreadID)
{
    id += uint2((uint)_StartPosX, (uint)_StartPosY);
    int brushID = _FinalTexID[id];
    if(brushID < 0)
    {
        return;
    }

    float value = (float)_HighlightIndex[brushID];
    if(value > 0)
    {
        _FinalTexColor[id] = value;
    }
}

[numthreads(32,32,1)]
void TimeRemap (uint2 id : SV_DispatchThreadID)
{
    id += uint2((uint)_StartPosX, (uint)_StartPosY);
    int brushID = _FinalTexID[id];
    if(brushID < 0)
    {
        return;
    }
    
    float pixel = _FinalTexColor[id];

    float4 time = _TimeRemap[brushID];
    float newPixel = Remap(pixel, time.x, time.y, time.z, time.w);
    _FinalTexColor[id] = float4(newPixel, 0, 0, 0);
}

[numthreads(32,32,1)]
void UpdateIDTex (uint2 id : SV_DispatchThreadID)
{
    id += uint2((uint)_StartPosX, (uint)_StartPosY);
    int brushID = _FinalTexID[id];
    if(brushID < 0)
    {
        return;
    }
    
    int newID = _IndexRemap[brushID].x;
    _FinalTexID[id] = newID;
}

[numthreads(1024,1,1)]
void RedrawBrushStroke (uint id : SV_DispatchThreadID)
{
    
}


