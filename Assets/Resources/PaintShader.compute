#pragma kernel PaintUnderOwnLine
#pragma kernel PaintUnderEverything
#pragma kernel PaintOverEverything
#pragma kernel PaintOverOwnLine
#pragma kernel Erase
#pragma kernel HighlightSelection
#pragma kernel EraseHighlight


RWTexture2D<float4> _ResultTex;
RWTexture2D<int> _IdTex;
RWTexture2D<float> _SelectTex;

float2 _CursorPos;
float2 _CursorPosPlusBrushSize;
float2 _LastCursorPos;
float2 _LastCursorPosPlusBrushSize;
float2 _StartPos;
float _BrushSize;
float _TimeColor;
float _PreviousTimeColor;
bool _FirstStroke;
bool _LastStroke;
bool _DrawOverOwnLine;
int _StrokeID;

float LineSegment2DSDF(const float2 p, const float2 a, const float2 b)
{
    const float2 ba = b - a;
    const float2 pa = p - a;
    const float k = saturate(dot(pa, ba) / dot(ba, ba));
    return length(pa - ba * k);
}

float2 ClosestPointOnLine(const float2 lineStart, const float2 lineEnd, const float2 position)
{
    const float2 lineDirection = normalize(lineEnd - lineStart);
    const float2 positionRelativeToStart = position - lineStart;
    const float projectionDistance = dot(positionRelativeToStart, lineDirection);
    return lineStart + projectionDistance * lineDirection;
}

float cubicBezierCircle(float t)
{
    float oneMinusT = 1.0 - t;
    return 3.0 * oneMinusT * oneMinusT * t * 0.0 + t * t * t * 1.0;
}

float CalculatePaintColor(float2 paintPos, float2 startPos, float2 endPos)
{
    const float2 paintPosOnLine = ClosestPointOnLine(startPos, endPos, paintPos);

    float distLine = distance(startPos, endPos);
    float distanceToPointA = distance(startPos, paintPosOnLine) / distLine;
    float paintColor = lerp(_PreviousTimeColor, _TimeColor, distanceToPointA);
    
    float distToLine = distance(paintPosOnLine, paintPos);
    distToLine = saturate((cubicBezierCircle(distToLine / _BrushSize) * _BrushSize) / distLine);
    
    float paintColorOutside = _TimeColor - lerp(_PreviousTimeColor, _TimeColor, distToLine);
    
    paintColor -= paintColorOutside;
    paintColor = clamp(paintColor, _PreviousTimeColor - (_TimeColor - _PreviousTimeColor), _TimeColor);
    
    return paintColor;
}

[numthreads(32,32,1)]
void PaintUnderOwnLine (uint3 id : SV_DispatchThreadID)
{
    const float2 paintPos = _StartPos.xy + id.xy;
    _LastCursorPos -= float2(0.01, 0.01);

    if(_IdTex[paintPos] == _StrokeID)
    {
        return;
    }

    if(distance(paintPos, _LastCursorPos) < _BrushSize + 1)
    {
        float2 AtoB = _CursorPos - _LastCursorPos;
        float2 paintPosToA = _LastCursorPos - paintPos;
        
        if(dot(AtoB, paintPosToA) > 0.0 && !_FirstStroke)
        {
            return;
        }
    }

    float paintColor = LineSegment2DSDF(paintPos, _LastCursorPos, _CursorPos);
    paintColor = 1 - smoothstep(_BrushSize, _BrushSize, paintColor);

    if(paintColor <= 0) { return; }

    paintColor = CalculatePaintColor(paintPos, _LastCursorPos, _CursorPos);

    _IdTex[paintPos] = _StrokeID;
    _ResultTex[paintPos] = float4(paintColor, paintColor, paintColor, 1);
}

[numthreads(32,32,1)]
void PaintUnderEverything (uint3 id : SV_DispatchThreadID)
{
    float2 paintPos = _StartPos.xy + id.xy;

    if(_IdTex[paintPos] != -1)
    {
        return;
    }

    const float2 AtoB = _CursorPos - _LastCursorPos;
    const float2 paintPosToA = _LastCursorPos - paintPos;
    
    if(dot(normalize(AtoB), paintPosToA) > 0.0 && !_FirstStroke)
    {
        return;
    }

    float paintColor = LineSegment2DSDF(paintPos, _LastCursorPos, _CursorPos);
    paintColor = 1 - smoothstep(_BrushSize, _BrushSize, paintColor);

    if(paintColor <= 0) { return; }

    paintColor = CalculatePaintColor(paintPos, _LastCursorPos, _CursorPos);

    _ResultTex[paintPos] = float4(paintColor, paintColor, paintColor, 1);

    _IdTex[paintPos] = _StrokeID;
}

[numthreads(32,32,1)]
void PaintOverOwnLine (uint3 id : SV_DispatchThreadID)
{
    const float2 paintPos = _StartPos.xy + id.xy;
    _LastCursorPos -= float2(0.01, 0.01);

    if(_IdTex[paintPos] != _StrokeID && _IdTex[paintPos] != -1)
    {
        return;
    }

    if(distance(paintPos, _LastCursorPos) < _BrushSize + 1)
    {
        float2 AtoB = _CursorPos - _LastCursorPos;
        float2 paintPosToA = _LastCursorPos - paintPos;
        
        if(dot(AtoB, paintPosToA) > 0.0 && !_FirstStroke)
        {
            return;
        }
    }

    float paintColor = LineSegment2DSDF(paintPos, _LastCursorPos, _CursorPos);
    paintColor = 1 - smoothstep(_BrushSize, _BrushSize, paintColor);

    if(paintColor <= 0) { return; }

    paintColor = CalculatePaintColor(paintPos, _LastCursorPos, _CursorPos);

    _IdTex[paintPos] = _StrokeID;
    _ResultTex[paintPos] = float4(paintColor, paintColor, paintColor, 1);
}

[numthreads(32,32,1)]
void PaintOverEverything (uint3 id : SV_DispatchThreadID)
{
    float2 paintPos = _StartPos.xy + id.xy;
    _LastCursorPos -= float2(0.01, 0.01);

    if(distance(paintPos, _LastCursorPos) < _BrushSize + 1)
    {
        float2 AtoB = _CursorPos - _LastCursorPos;
        float2 paintPosToA = _LastCursorPos - paintPos;
        
        if(dot(AtoB, paintPosToA) > 0.0 && !_FirstStroke)
        {
            return;
        }
    }

    float paintColor = LineSegment2DSDF(paintPos, _LastCursorPos, _CursorPos);
    paintColor = 1 - smoothstep(_BrushSize, _BrushSize, paintColor);

    if(paintColor <= 0) { return; }

    paintColor = CalculatePaintColor(paintPos, _LastCursorPos, _CursorPos);

    _ResultTex[paintPos] = float4(paintColor, paintColor, paintColor, 1);
    _IdTex[paintPos] = _StrokeID;
}

[numthreads(32,32,1)]
void Erase (uint3 id : SV_DispatchThreadID)
{
    float2 paintPos = _StartPos.xy + id.xy;
    _LastCursorPos -= float2(0.01, 0.01);

    float paintColor = LineSegment2DSDF(paintPos, _LastCursorPos, _CursorPos);
    paintColor = 1 - smoothstep(_BrushSize, _BrushSize, paintColor);

    if(paintColor <= 0) { return; }

    _IdTex[paintPos] = -1;
    _ResultTex[paintPos] = float4(1, 1, 1, 1);
}

[numthreads(32,32,1)]
void HighlightSelection (uint3 id : SV_DispatchThreadID)
{
    float2 paintPos = _StartPos.xy + id.xy;
    _LastCursorPos -= float2(0.01, 0.01);

    float paintColor = LineSegment2DSDF(paintPos, _LastCursorPos, _CursorPos);
    paintColor = smoothstep(_BrushSize, 0, paintColor);
    
    if(paintColor <= 0) { return; }

    _SelectTex[paintPos] = 0;
}

[numthreads(32,32,1)]
void EraseHighlight (uint3 id : SV_DispatchThreadID)
{
    float2 paintPos = _StartPos.xy + id.xy;
    _LastCursorPos -= float2(0.01, 0.01);

    float paintColor = LineSegment2DSDF(paintPos, _LastCursorPos, _CursorPos);
    paintColor = 1 - smoothstep(_BrushSize, _BrushSize, paintColor);

    if(paintColor <= 0) { return; }

    _SelectTex[paintPos] = 1;
}


