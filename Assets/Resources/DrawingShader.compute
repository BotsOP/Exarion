#pragma kernel PaintUnderOwnLine
#pragma kernel PaintUnderEverything
#pragma kernel PaintOverEverything
#pragma kernel PaintOverOwnLine
#pragma kernel Erase
#pragma kernel WriteToReverse

RWTexture2D<float> _ResultTex;
RWTexture2D<float4> _ResultTexReverse;
RWTexture2D<int> _IDTex;

float2 _CursorPos;
float2 _CursorPosPlusBrushSize;
float2 _LastCursorPos;
float2 _LastCursorPosPlusBrushSize;
float2 _StartPos;
float _BrushSize;
float _TimeColor;
float _PreviousTimeColor;
float _TimeDifference;
bool _FirstStroke;
bool _LastStroke;
bool _DrawOverOwnLine;
int _StrokeID;

float LineSegment2DSDF(const float2 p, const float2 a, const float2 b)
{
    const float2 ba = b - a;
    const float2 pa = p - a;
    const float k = saturate(dot(pa, ba) / dot(ba, ba));
    return length(pa - ba * k);
}

float2 ClosestPointOnLine(const float2 lineStart, const float2 lineEnd, const float2 position)
{
    const float2 lineDirection = normalize(lineEnd - lineStart);
    const float2 positionRelativeToStart = position - lineStart;
    const float projectionDistance = dot(positionRelativeToStart, lineDirection);
    return lineStart + projectionDistance * lineDirection;
}

float CubicCircle(float t)
{
    return t * t * t;
}

float LinearToCircle(float t)
{
    //return sqrt(1 - pow(t - 0.9, 2));
    return sqrt(4 - pow(t * 2 - 2, 2)) / 2;
}

float Remap (float value, float from1, float to1, float from2, float to2) 
{
    return (value - from1) / (to1 - from1) * (to2 - from2) + from2;
}

//start of brushstrtoke is already drawn
float CalculatePaintColor(float2 paintPos, float2 startPos, float2 endPos)
{
    const float2 paintPosOnLine = ClosestPointOnLine(startPos, endPos, paintPos);
    
    float distLine = distance(startPos, endPos) + _BrushSize;
    float distanceToPointA = (distance(startPos, paintPosOnLine) + _BrushSize) / distLine;
    float paintColor = Remap(distanceToPointA, 0, 1, 0, 0.9);

    float distToLine = distance(paintPosOnLine, paintPos);
    distToLine = distToLine / _BrushSize;
    paintColor += CubicCircle(distToLine) / 10;
                
    paintColor = lerp(_PreviousTimeColor, _TimeColor, saturate(paintColor));
                
    return paintColor;
}

[numthreads(32,32,1)]
void PaintUnderOwnLine (uint3 id : SV_DispatchThreadID)
{
}

[numthreads(32,32,1)]
void PaintUnderEverything (uint3 id : SV_DispatchThreadID)
{
    float2 paintPos = _StartPos.xy + id.xy;

    if(_IDTex[paintPos] == 1)
    {
        return;
    }

    float paintColor = LineSegment2DSDF(paintPos, _LastCursorPos, _CursorPos);
    
    if(paintColor > _BrushSize)
    {
        return;
    }
    
    paintColor = CalculatePaintColor(paintPos, _LastCursorPos, _CursorPos);

    _ResultTex[paintPos] = paintColor;
    _IDTex[paintPos] = 1;
}

[numthreads(32,32,1)]
void PaintOverOwnLine (uint3 id : SV_DispatchThreadID)
{
    const float2 paintPos = _StartPos.xy + id.xy;

    if(_IDTex[paintPos] != _StrokeID && _IDTex[paintPos] != -1)
    {
        return;
    }

    if(distance(paintPos, _LastCursorPos) < _BrushSize + 1)
    {
        float2 AtoB = _CursorPos - _LastCursorPos;
        float2 paintPosToA = _LastCursorPos - paintPos;
        
        if(dot(AtoB, paintPosToA) > 0.0 && !_FirstStroke)
        {
            return;
        }
    }

    float paintColor = LineSegment2DSDF(paintPos, _LastCursorPos, _CursorPos);
    paintColor = 1 - smoothstep(_BrushSize, _BrushSize, paintColor);

    if(paintColor <= 0) { return; }

    paintColor = CalculatePaintColor(paintPos, _LastCursorPos, _CursorPos);

    _IDTex[paintPos] = _StrokeID;
    _ResultTex[paintPos] = paintColor;
}

[numthreads(32,32,1)]
void PaintOverEverything (uint3 id : SV_DispatchThreadID)
{
    float2 paintPos = _StartPos.xy + id.xy;

    if(distance(paintPos, _LastCursorPos) < _BrushSize + 1)
    {
        float2 AtoB = _CursorPos - _LastCursorPos;
        float2 paintPosToA = _LastCursorPos - paintPos;
        
        if(dot(AtoB, paintPosToA) > 0.0 && !_FirstStroke)
        {
            return;
        }
    }

    float paintColor = LineSegment2DSDF(paintPos, _LastCursorPos, _CursorPos);
    paintColor = 1 - smoothstep(_BrushSize, _BrushSize, paintColor);

    if(paintColor <= 0) { return; }

    paintColor = CalculatePaintColor(paintPos, _LastCursorPos, _CursorPos);

    _ResultTex[paintPos] = paintColor;
    _IDTex[paintPos] = _StrokeID;
}

//Doesnt always have to erase the result tex
[numthreads(32,32,1)]
void Erase (uint3 id : SV_DispatchThreadID)
{
    float2 paintPos = _StartPos.xy + id.xy;

    float paintColor = LineSegment2DSDF(paintPos, _LastCursorPos, _CursorPos);
    paintColor = 1 - smoothstep(_BrushSize, _BrushSize, paintColor);

    if(paintColor <= 0) { return; }

    _IDTex[paintPos] = -1;
    _ResultTex[paintPos] = 250;
}

bool _WriteToG;
[numthreads(32,32,1)]
void WriteToReverse (uint2 id : SV_DispatchThreadID)
{
    if(!_WriteToG)
    {
        _ResultTexReverse[id] = float4(_ResultTex[id], 1, 1, 1);
    }
    else
    {
        _ResultTexReverse[id] = float4(_ResultTexReverse[id].r, _ResultTex[id], 1, 1);
    }
}


